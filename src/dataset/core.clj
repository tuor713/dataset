(ns dataset.core
  "Dataset library built on top of (backported) reducers library."
  (:require [backport.clojure.core.reducers :as r]
            [backport.clojure.core.protocols :as p])
  (:use [clojure.set :only [union intersection]]))


;; Additional protocols

(defprotocol Schematic
  (columns [self] "Returns a sequence of columns"))

(defn schematic? [dataset] (instance? dataset.core.Schematic dataset))

(defn generated-dataset 
  "Dataset generated by a function taking a reducer input. Useful for resource managed datasets i.e. those that need to open resources and close them after use.

The generator function takes an a single argument, which is the function to apply to the data set (dataset -> result)."
  ([generator]
     (reify 
       clojure.lang.Seqable
       (seq [self] (r/into [] self))

       p/CollReduce
       (coll-reduce [_ f]
         (generator #(r/reduce f %)))
       (coll-reduce [_ f val]
         (generator #(r/reduce f val %)))))
  ([schema generator]
     (reify 
       Schematic 
       (columns [self] schema)

       clojure.lang.Seqable
       (seq [self] (r/into [] self))

       p/CollReduce
       (coll-reduce [_ f]
         (generator #(r/reduce f %)))
       (coll-reduce [_ f val]
         (generator #(r/reduce f val %))))))

(deftype InMemoryDataSet [schema records]
  Schematic 
  (columns [self] schema)

  clojure.lang.Seqable
  (seq [_] records)
  
  clojure.lang.Counted
  (count [_] (count records))
  
  p/CollReduce
  (coll-reduce [coll f]
    (p/coll-reduce records f))
  (coll-reduce [coll f val]
    (p/coll-reduce records f val)))


(defn dataset [recs]
  (when (seq recs)
    (let [ks (distinct (mapcat keys recs))
          sm (apply create-struct ks)]
      (InMemoryDataSet. 
       ks 
       (map #(apply struct sm (map % ks)) recs)))))

(defn cache 
  "Creates an in-memory cached copy of the dataset to prevent reevaluation"
  [ds]
  (if (instance? InMemoryDataSet ds)
    ds
    (dataset (r/into [] ds))))


;; Operations on datasets (and other reducibles)

(defn join [lhs rhs lhskey rhskey join-type]
  (let [lhs-groups (r/group-by lhskey lhs)
        rhs-groups (r/group-by rhskey rhs)
        result-keys (join-type (set (keys lhs-groups)) (set (keys rhs-groups)))]
    (if (and (schematic? lhs) (schematic? rhs))
      (let [ks (distinct (concat (columns lhs) (columns rhs)))
            sm (apply create-struct ks)]
        (InMemoryDataSet.
         ks
         (for [k result-keys
               l (lhs-groups k)
               r (rhs-groups k)]
           (apply struct sm
                  (map #(get r % (get l %)) ks)))))
      (dataset 
       (for [k result-keys
             l (lhs-groups k)
             r (rhs-groups k)]
         (merge l r))))))

(def inner-join #(join %1 %2 %3 %4 intersection))
(def outer-join #(join %1 %2 %3 %4 union))
(def left-join #(join %1 %2 %3 %3 (fn [l _] l)))
(def right-join #(left-join %2 %1 %4 %3))

